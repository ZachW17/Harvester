/*
 * Public static class SpawnWaves
 * @author Freddy Garcia/Theodore Greene
 * 
 * Version: $1.0.0$
 * 
 * Revisions: 
 *          1.0.1 (Theodore Greene)
 *              -Added attributes and the basics of file reading
 *          1.0.2 (Theodore Greene)
 *              -Added Methods, major overhalls into ModLoader
 * 
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;

using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.GamerServices;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;

namespace Harvester
{
    /// <summary>
    /// This class handles the way waves will spawn in the levels (tentative)
    /// </summary>
    public class SpawnManager : Game
    {
        private Game game = new Game();
        private SpriteBatch _spawnSpriteBatch;

        public SpriteBatch SpawnSpriteBatch
        {
            get { return _spawnSpriteBatch; }
            set { _spawnSpriteBatch = value; }
        }

        ///// <summary>
        ///// The time for the next enemy wave to spawn
        ///// </summary>
        //public int EnemySpawnTimer
        //{
        //    get { return enemySpawnTimer; }
        //    set { enemySpawnTimer = value; }
        //}

        ///<summary>
        ///Set up the Singleton
        ///</summary>
        #region
        //Here is how this works

        //First make a static variable of type SpawnManager
        private static SpawnManager _instance;

        //Then make a property so you can access it
        public static SpawnManager Instance
        {
            get
            {
                //if it hasn't been initilized
                if (_instance == null)
                {
                    //Make a new one
                    _instance = new SpawnManager();
                }

                //Otherwise return the instance of
                return _instance;
            }
        }
        #endregion
        /// <summary>
        /// Private contructor ensures nothing can make a new Asset Manager
        /// </summary>
        private SpawnManager()
        {

        }

        /// <summary>
        /// Pass the file name to the AssetManager to get back data
        /// Use the data to create formation as a list of enemies
        /// Use the list of enemy ships to spawn them
        /// </summary>
        /// <param name="frequency">A number to decide the frequency(time) of the waves</param>
        /// <param name="amount">A number to decide the number waves at a time</param>
        /// <param name="fileName">The file name to be used</param>
        public void SpawnAWave(int frequency, int amount, string fileName)
        {
            //Fill list
            #region
            //A list of enemies to be filled
            ArrayList enemyLoadList = AssetManager.Instance.LoadFromSource(fileName, "Formation");

            //The final list of completed enemies to be spawned
            List<Ship> finalEnemyList = new List<Ship>();

            //For the length of the array list
            for (int i = 0; i < enemyLoadList.Count; i += 4)
            {
                //Parse the string to find what enum it is, no try catch so be careful. There shouldbe no way you can mess it up but file io is strange
                ShipType loadedShipType = (ShipType)Enum.Parse(typeof(ShipType), (string)enemyLoadList[i + 3]);

                //add a ship to the list since the pattern in enemyLoadList is int,int,string you do [i],[i+1],[i+2],[i+3] then increment by three to get the next quad
                Ship temp = ShipManager.CreateShip(new Rectangle((int)enemyLoadList[i], (int)enemyLoadList[i + 1], 50, 50), AssetManager.Instance.FindTexture((string)enemyLoadList[i + 2]), 100, 100, 100, AssetManager.Instance.FindTexture("enemy_bullet"), loadedShipType);

                finalEnemyList.Add(temp);
            }

            // Testing purposes only
            foreach (Ship s in finalEnemyList)
            {
                Console.WriteLine(s.ToString());
            }


            //graphics = new GraphicsDeviceManager(this);

            //Update all the enemies
            #endregion
            ////Draw the enemies
            //for (int i = 0; i < finalEnemyList.Count; i++)
            //{
            //    if (finalEnemyList[i].TheShipType == ShipType.EnemyFighter && finalEnemyList[i].ShipIsActive == true)
            //    {
            //        finalEnemyList[i].Draw(_spawnSpriteBatch);

            //    }
            //    if (finalEnemyList[i].TheShipType == ShipType.Kamikaze && finalEnemyList[i].ShipIsActive == true)
            //    {
            //        finalEnemyList[i].Draw(_spawnSpriteBatch);
            //    }

            //    finalEnemyList[i].Draw(_spawnSpriteBatch);
            // }
        }
    }
}